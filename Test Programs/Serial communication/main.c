
//#include "io430.h"
#include "msp430x552x.h"
#include <signal.h>
#include "time.h"

void sendData();
void Receive(int received);
int Checksum(int check[],int len);
void sendStop();

int received[20];
int sent[17];

void main(void) {
    WDTCTL = WDTPW + WDTHOLD;                 // Stop WDT
 // RTCCTL01 = RTCBCD | 0x20;
 RTCCTL01 = RTCBCD | RTCHOLD | 0x20 | RTCTEV_0;
 // Enable, BCD, int every minute
 RTCSEC = 0x00; // Set Seconds
 RTCMIN = 0x00; // Set Minutes
 RTCHOUR = 0x08; // Set Hours
 RTCDOW = 0x02; // Set DOW
 RTCDAY = 0x23; // Set Day
 RTCMON = 0x11; // Set Month
 RTCYEAR = 0x2009; // Set Year
 RTCCTL01 = ~RTCHOLD; // Enable RTC
 
 //this is for serial communication
  P3SEL |= BIT3+BIT4;                       // P3.3,4 = USCI_A0 TXD/RXD
  UCA0CTL1 |= UCSWRST;                      // **Put state machine in reset**
  UCA0CTL1 |= UCSSEL_2;                     // SMCLK
  UCA0BR0 = 9;                              // 1MHz 115200 (see User's Guide)
  UCA0BR1 = 0;                              // 1MHz 115200
  UCA0MCTL |= UCBRS_1 + UCBRF_0;            // Modulation UCBRSx=1, UCBRFx=0
  UCA0CTL1 &= ~UCSWRST;                     // **Initialize USCI state machine**
  UCA0IE |= UCRXIE;                         // Enable USCI_A0 RX interrupt
  
 __bis_SR_register(LPM3_bits + GIE);       // Enter LPM3, enable ints 
 for(;;)
 {
 }
}

__interrupt void basic_timer(void) {
  P5OUT ^= 0x02; // Toggle P5.1 every minute
}

// Echo back RXed character, confirm TX buffer is ready first
/*#pragma vector=USCI_A0_VECTOR
__interrupt void USCI_A0_ISR(void)
{
  switch(__even_in_range(UCA0IV,4))
  {
  case 0:break;                             // Vector 0 - no interrupt
  case 2:                                   // Vector 2 - RXIFG
    while (!(UCA0IFG&UCTXIFG));             // USCI_A0 TX buffer ready?
    UCA0TXBUF = UCA0RXBUF;                  // TX -> RXed character
    break;
  case 4:break;                             // Vector 4 - TXIFG
  default: break;
  }
}*/

/*void TIME_getDate (TIME_date_t *const date)
{
     //RTCCTL |= RTCHOLD;
     date->year = RTCYEARH << 8 | RTCYEARL;
     date->month = RTCMON;
     date->day = RTCDAY;
     date->hour = RTCHOUR;
     date->min = RTCMIN;
     date->sec = RTCSEC;
     //RTCCTL &= ~RTCHOLD;
}
 
void TIME_setDate (const TIME_date_t *date)
{
     RTCCTL |= RTCHOLD;
     RTCYEARH = date->year >> 8;
     RTCYEARL = date->year & 0xFF;
     RTCMON = date->month;
     RTCDAY = date->day;
     RTCHOUR = date->hour;
     RTCMIN = date->min;
     RTCSEC = date->sec;
     RTCCTL &= ~RTCHOLD;
}*/

void Receive(int receive) // takes in one byte and does what it is suppose to do.
{
  //int stop[] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f};
  int startByte = 0x8C;
  int send = 0x10;
  int ack = 0xA5;
  int err = 0x33;
  // 0x8C is the starting value
  if(receive == startByte)
  {
    // send 0x8c
  }
  // 0x10 get data from the flash disc
  else if(receive == send)
  {
   sendData();
  }
  // 0xA5 acknowledge message
  if(receive == ack)
  {
    // send another batch of data.
    sendData();
  }
  // 0x33 error message wasn't received.
  if(receive == err)
  {
    // error resend previous data.
  }
}
void sendData()
{
  //uart.
  int send[] = {0x05,0x09,0x08,0x05,0x09,0x08,0x05,0x09,0x08,0x05,0x09,0x08,0x05,0x09,0x08,0}; // the message to send to the computer without the checksum.
  int checksum;
  // send data from flash need to figure out how better to do this.
  checksum = Checksum(send,15);
  send[15] = checksum;
  //send message to computer
  for(int i = 0;i<16;i++)
  {
    //send one byte at a time.
    while (!(UCA0IFG&UCTXIFG));
    UCA0TXBUF = send[i];
  }
}
int Checksum(int check[], int len)
{
  int CC_TABLE[] =
            {
                0x00,0x5E,0xBC,0xE2,0x61,0x3F,0xDD,0x83,0xC2,0x9C,0x7E,0x20,0xA3,0xFD,0x1F,0x41,
                0x9D,0xC3,0x21,0x7F,0xFC,0xA2,0x40,0x1E,0x5F,0x01,0xE3,0xBD,0x3E,0x60,0x82,0xDC,
                0x23,0x7D,0x9F,0xC1,0x42,0x1C,0xFE,0xA0,0xE1,0xBF,0x5D,0x03,0x80,0xDE,0x3C,0x62,
                0xBE,0xE0,0x02,0x5C,0xDF,0x81,0x63,0x3D,0x7C,0x22,0xC0,0x9E,0x1D,0x43,0xA1,0xFF,
                0x46,0x18,0xFA,0xA4,0x27,0x79,0x9B,0xC5,0x84,0xDA,0x38,0x66,0xE5,0xBB,0x59,0x07,
                0xDB,0x85,0x67,0x39,0xBA,0xE4,0x06,0x58,0x19,0x47,0xA5,0xFB,0x78,0x26,0xC4,0x9A,
                0x65,0x3B,0xD9,0x87,0x04,0x5A,0xB8,0xE6,0xA7,0xF9,0x1B,0x45,0xC6,0x98,0x7A,0x24,
                0xF8,0xA6,0x44,0x1A,0x99,0xC7,0x25,0x7B,0x3A,0x64,0x86,0xD8,0x5B,0x05,0xE7,0xB9,
                0x8C,0xD2,0x30,0x6E,0xED,0xB3,0x51,0x0F,0x4E,0x10,0xF2,0xAC,0x2F,0x71,0x93,0xCD,
                0x11,0x4F,0xAD,0xF3,0x70,0x2E,0xCC,0x92,0xD3,0x8D,0x6F,0x31,0xB2,0xEC,0x0E,0x50,
                0xAF,0xF1,0x13,0x4D,0xCE,0x90,0x72,0x2C,0x6D,0x33,0xD1,0x8F,0x0C,0x52,0xB0,0xEE,
                0x32,0x6C,0x8E,0xD0,0x53,0x0D,0xEF,0xB1,0xF0,0xAE,0x4C,0x12,0x91,0xCF,0x2D,0x73,
                0xCA,0x94,0x76,0x28,0xAB,0xF5,0x17,0x49,0x08,0x56,0xB4,0xEA,0x69,0x37,0xD5,0x8B,
                0x57,0x09,0xEB,0xB5,0x36,0x68,0x8A,0xD4,0x95,0xCB,0x29,0x77,0xF4,0xAA,0x48,0x16,
                0xE9,0xB7,0x55,0x0B,0x88,0xD6,0x34,0x6A,0x2B,0x75,0x97,0xC9,0x4A,0x14,0xF6,0xA8,
                0x74,0x2A,0xC8,0x96,0x15,0x4B,0xA9,0xF7,0xB6,0xE8,0x0A,0x54,0xD7,0x89,0x6B,0x35
            };
  int cc_byte;
  cc_byte = 0xFF;
  for (int i = 0;i<len;i++)
  {
    cc_byte = CC_TABLE[(cc_byte ^ check[i])];
  }
  return cc_byte;
}
void sendStop()
{
  int stop[] = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00};
  // send stop info
  int checksum;
  checksum = Checksum(stop,15);
  stop[15] = checksum;
  for(int i = 0;i<16;i++)
  {
    //send one byte at a time.
    while (!(UCA0IFG&UCTXIFG));
    UCA0TXBUF = stop[i];
  }
}